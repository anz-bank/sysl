let export = \rel \namespace \package
  let rec toProtoType = \field
    let ft = field.fieldType;
    let tags = {field} --> rel.tag.field;
    let opt = field.fieldOpt?:false;
    cond ft {
      (:sequence, ...): $`repeated ${toProtoType(field +> (fieldType: sequence))}`,
      (:set, ...): $`repeated ${toProtoType(field +> (fieldType: set))}`,
      # TODO: Constraints, tags.
        (:primitive, ...):
        let protoValOrPrimitive = \t
          let isPrimitive = t <: {
            'double',
            'float',
            'float32',
            'float64',
            'int32',
            'int64',
            'uint32',
            'uint64',
            'bool',
            'string',
            'bytes'
          };
          cond {
            isPrimitive && opt:
              let t = //str.title((t <: {'float32', 'float64'} && 'float') || t);
              $`google.protobuf.${t}Value`,
            !isPrimitive:
              $`google.protobuf.${//str.title(t)}`,
            _: t
          };
        cond primitive {
          'BYTES':    protoValOrPrimitive('bytes'),
          'BOOL':     protoValOrPrimitive('bool'),
          'INT':      protoValOrPrimitive('int32'),
          'FLOAT':    protoValOrPrimitive('float32'),
          'DECIMAL':  protoValOrPrimitive('float64'),
          'STRING':   protoValOrPrimitive('string'),
          'DATE':     protoValOrPrimitive('string'),
          'DATETIME': protoValOrPrimitive('timestamp'),
        },
      (:typePath, ...): $`${typePath::.}`,
    } || //error($`unhandled type ${ft}`)
  ;

  let orderedFields =
    let src = rel.src?.field?:{} => (
      :.appName,
      :.typeName,
      :.fieldName,
      line:
        cond .fieldSrcs {
          [(start: (:line, ...), ...), ...]: line
        }
    );
    \fields
      cond {
        src: ((fields <&> src) rank (:.line)) => (@: .line, @item: .~|line|),
        _: fields orderby .fieldName
      }
  ;

  let nonEnums = (rel.type => .|appName, typeName|) &~ (rel.enum => .|appName, typeName|);

  $`
    // {"sysl": {"namespace": "${namespace}"}}

    // File generated by Sysl. DO NOT EDIT.

    syntax = "proto3";

    package ${package};

    option go_package = "${package}";

    ${cond {//rel.union(rel.field => .'fieldType'.'primitive'?:'' = 'DATETIME'): 'import "google/protobuf/timestamp.proto";'}}
    import "google/protobuf/wrappers.proto";

    ${rel.enum orderby .typeName >> $`
      enum ${.typeName} {
        ${.enumItems orderby .@value >> $`${.@} = ${.@value};`::\i}
      }
    `::\n\n}
    ${nonEnums orderby .typeName >> $`
      message ${.typeName} {
        ${orderedFields({.} <&> rel.field) >>> \i \f
          let {index} = ({f +> (fieldAnnoName: 'proto_number')} --> rel.anno.field => .fieldAnnoValue) || {i+1};
          $`
            ${toProtoType(f)} ${f.fieldName} = ${index};
          `
        ::\i}
      }
    `::\n\n}
  ` ++ '\n'
;

export
