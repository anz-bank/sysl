let export = \rel \namespace \package

  let rec toProtoType = \field
    let ft = field.fieldType;
    let tags = {field} --> rel.tag.field;

    cond ft {
      (:sequence, ...): $`repeated ${toProtoType(field +> (fieldType: sequence))}`,
      (:set, ...): $`repeated ${toProtoType(field +> (fieldType: set))}`,
      # TODO: Constraints, tags.
      (primitive: 'BYTES'): 'bytes',
      (primitive: 'BOOL'): 'bool',
      (primitive: 'INT'): 'int32',
      (primitive: 'FLOAT'): 'float32',
      (primitive: 'DECIMAL'): 'float64',
      (primitive: 'STRING'): 'string',
      (:typePath, ...): $`${typePath::.}`,
      _: //error($`unhandled type ${ft}`)
    }
  ;

  let nonEnums = (rel.type => .|appName, typeName|) &~ (rel.enum => .|appName, typeName|);

  $`
    // {"sysl": {"namespace": "${namespace}"}}

    // File generated by Sysl. DO NOT EDIT.

    syntax = "proto3";

    package ${package};

    option go_package = "${package}";

    ${rel.enum orderby .typeName >> $`
      enum ${.typeName} {
        ${.enumItems orderby .@value >> $`${.@} = ${.@value};`::\i}
      }
    `::\n\n}
    ${nonEnums orderby .typeName >> $`
      message ${.typeName} {
        ${({.} <&> rel.field orderby .fieldName) >>> \i \f
          let {index} = ({f +> (fieldAnnoName: 'proto_number')} --> rel.anno.field => .fieldAnnoValue) || {i+1};
          $`
            ${toProtoType(f)} ${f.fieldName} = ${index};
          `
        ::\i}
      }
    `::\n\n}
  ` ++ '\n'
;

export