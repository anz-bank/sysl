# Returns a map of Sysl specs imported from some JSON Schema data.
\input
    let appName = //seq.split('::', input.appName);
    let data = input.content;
    let (:decodeSimple, ...) = //{github.com/arr-ai/arrai/contrib/json};
    let json = decodeSimple(data);

    let policy = \key \policies
        cond policies where .@item.policyId = key {
            [(:params, ...)]: (//dict(params) single).@value
        }
    ;

    let toAnno = \kind \values
        //rel.union(values => \v v.anno => (
            //tuple({$`${kind}AnnoName`: .@, $`${kind}AnnoValue`: .@value}))
                +> //tuple(//dict(v) where //seq.has_suffix('Name', .@))
        )
    ;
    let resolveRef = \type
        # TODO: Get the referenced property programmatically. It's not obvious from the JSON.
        let t = //seq.split('/', type.resourceCollection(0).path)(1);
        $`${t}._id`
    ;

    # Types interpreted from JSON Schema that represent null.
    let nullTypes = {{}, 'null'};

    let rec fieldType = \field
        cond field.type?:'' {
            'boolean': 'bool',
            'array': cond field.items.type {
                'relationship': $'sequence of ${resolveRef(field.items)}',
                # TODO: Nested types.
                'object': 'sequence of any',
                _: $'sequence of ${field.items.type}',
            },
            'relationship': resolveRef(field),
            # TODO: Nested types.
            'object': 'any',
            'null': 'empty',
            # Ignore nullability here, it's handled by fieldOpt.
            [...]: cond field.type => .@item where . !<: nullTypes {
                {type}: fieldType(field +> (:type)),
                # TODO: Handle other union types.
                _: 'any'
            },
            t: t,
        }
    ;

    # Returns truthy if the field is nullable (not required, or null as possible type).
    let fieldOpt = \schema \fieldName \field
        let requiredFields = schema.required?:{} => .@item;
        let nullable = cond field.type?:'' {
            'null': true,
            [...]: nullTypes & (field.type => .@item)
        };
        nullable || (fieldName !<: requiredFields)
    ;

    let types = json.objects => .@item =>
        let schema = (.).schema?:();
        let type = (:appName, typeName: .name);
        type +> (
            anno: {
                'displayName': schema.title?:'',
                'description': schema.description?:'',
            },
            fields: cond schema {
                (:properties, ...):
                    //dict(properties) => \(@:fieldName, @value:field)
                        type +> (
                            :fieldName,
                            fieldType: fieldType(field),
                            fieldOpt: fieldOpt(schema, fieldName, field),
                            fieldConstraint: (length: (
                                min: policy('minimum-length', field.policies?:{}),
                                max: policy('maximum-length', field.policies?:{}),
                            )),
                            anno: {
                                'description': field.description?:'',
                            },
                        )
                ,
                _: type,
            },
        )
    ;
    let fields = //rel.union(types => .fields);
    let sysl = (
        app: {(:appName, appLongName: '')},
        type: types => .~|anno, fields|,
        field: fields => .~|anno|,
    );
    let sysl = sysl +> (
        anno: (
            type: toAnno('type', types),
            field: toAnno('field', fields),
        ),
        src: (
            app: sysl.app => .|appName| +> (appSrc: (file: $`${appName::_}.sysl`, start: (line: 0))),
            type: sysl.type => .|appName, typeName| +> (typeSrc: (file: $`${appName::_}.sysl`, start: (line: 0))),
            field: sysl.field => .|appName, typeName, fieldName| +> (fieldSrc: (file: $`${appName::_}.sysl`, start: (line: 0))),
        )
    );

    let prependGenComment = \str $`
        # Code generated by Sysl.

        ${str}
    `;

    prependGenComment((//{github.com/anz-bank/sysl/pkg/arrai/reconstruct}(sysl) single).@value)
