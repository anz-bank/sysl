package main

import (
	"bytes"
	"flag"
	"regexp"
	"testing"

	sysl "github.com/anz-bank/sysl/src/proto"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

const plantumlHeader = `''''''''''''''''''''''''''''''''''''''''''
''                                      ''
''  AUTOGENERATED CODE -- DO NOT EDIT!  ''
''                                      ''
''''''''''''''''''''''''''''''''''''''''''

@startuml
hide stereotype
scale max 16384 height
skinparam component {
  BackgroundColor FloralWhite
  BorderColor Black
  ArrowColor Crimson
}`

//nolint:gochecknoglobals
var (
	reAs                = regexp.MustCompile(`\[(\w+)\] as _\d+`)
	reAsWithHighlight   = regexp.MustCompile(`\[(\w+)\] as _\d+ <<highlight>>`)
	rePoint             = regexp.MustCompile(`_\d+ --> _\d+`)
	rePointWithIndirect = regexp.MustCompile(`_\d+ --> _\d+ <<indirect>>`)
	rePackage           = regexp.MustCompile(`package "(\w+)" {`)
)

func TestGenerateIntegrations(t *testing.T) {
	m, _ := Parse("demo/simple/sysl-ints.sysl", "../../")
	require.NotNil(t, m)

	stmt := &sysl.Statement{}
	args := &Args{"", "Project", false, false}
	apps := []string{"System1", "IntegratedSystem", "System2"}
	highlights := MakeStrSet("IntegratedSystem", "System1", "System2")
	s1 := MakeAppElement("IntegratedSystem", "integrated_endpoint_1")
	t1 := MakeAppElement("System1", "endpoint")
	dep1 := AppDependency{
		Self:      s1,
		Target:    t1,
		Statement: stmt,
	}
	deps := map[string]AppDependency{
		"IntegratedSystem:integrated_endpoint_1:System1:endpoint": dep1,
	}
	endpt := &sysl.Endpoint{
		Name: "_",
		Stmt: []*sysl.Statement{
			{Stmt: &sysl.Statement_Action{Action: &sysl.Action{Action: "IntegratedSystem"}}},
			{Stmt: &sysl.Statement_Action{Action: &sysl.Action{Action: "System1"}}},
		},
	}
	intsParam := &IntsParam{apps, highlights, deps, m.GetApps()["Project"], endpt}
	r := GenerateView(args, intsParam, m)

	require.NotNil(t, r)

	expected := plantumlHeader + `
[IntegratedSystem] as _0 <<highlight>>
[System1] as _1 <<highlight>>
_0 --> _1
@enduml`

	assert.Equal(t, expected, r)
}

type intsArg struct {
	rootModel string
	title     string
	output    string
	project   string
	filter    string
	modules   string
	exclude   []string
	clustered bool
	epa       bool
}

func TestGenerateIntegrationsWithTestFile(t *testing.T) {
	// Given
	args := &intsArg{
		rootModel: "./tests/",
		modules:   "integration_test.sysl",
		output:    "%(epname).png",
		project:   "Project",
	}
	expectContent := plantumlHeader + `
[IntegratedSystem] as _0 <<highlight>>
[System1] as _1 <<highlight>>
_0 --> _1
@enduml`
	expected := map[string]string{
		"_.png": expectContent,
	}

	// When
	result := GenerateIntegrations(args.rootModel, args.title, args.output,
		args.project, args.filter, args.modules, args.exclude, args.clustered, args.epa)

	// Then
	assert.Equal(t, expected, result)
}

func TestGenerateIntegrationsWithDependencySetTestFile(t *testing.T) {
	// Given
	args := &intsArg{
		rootModel: "./tests/",
		modules:   "integration_dependency_set_test.sysl",
		output:    "%(epname).png",
		project:   "Project",
	}
	expectContent := plantumlHeader + `
[IntegratedSystem] as _0 <<highlight>>
[System1] as _1 <<highlight>>
_0 --> _1
@enduml`
	expected := map[string]string{
		"_.png": expectContent,
	}

	// When
	result := GenerateIntegrations(args.rootModel, args.title, args.output,
		args.project, args.filter, args.modules, args.exclude, args.clustered, args.epa)

	// Then
	assert.Equal(t, expected, result)
}

func TestGenerateIntegrationsWithTestFileAndFilters(t *testing.T) {
	// Given
	args := &intsArg{
		rootModel: "./tests/",
		modules:   "integration_test.sysl",
		output:    "%(epname).png",
		project:   "Project",
		filter:    "test",
	}
	expected := map[string]string{}

	// When
	result := GenerateIntegrations(args.rootModel, args.title, args.output,
		args.project, args.filter, args.modules, args.exclude, args.clustered, args.epa)

	// Then
	assert.Equal(t, expected, result)
}

func TestGenerateIntegrationsWithImmediatePredecessors(t *testing.T) {
	// Given
	args := &intsArg{
		rootModel: "./tests/",
		modules:   "integration_immediate_predecessors_test.sysl",
		output:    "%(epname).png",
		project:   "Project",
	}

	// When
	result := GenerateIntegrations(args.rootModel, args.title, args.output,
		args.project, args.filter, args.modules, args.exclude, args.clustered, args.epa)

	// Then
	assert.Len(t, reAs.FindAllString(result["_.png"], -1), 3)
	assert.Len(t, reAsWithHighlight.FindAllString(result["_.png"], -1), 2)
	assert.Len(t, rePoint.FindAllString(result["_.png"], -1), 2)
}

func TestGenerateIntegrationsWithExclude(t *testing.T) {
	// Given
	args := &intsArg{
		rootModel: "./tests/",
		modules:   "integration_excludes_test.sysl",
		output:    "%(epname).png",
		project:   "Project",
	}
	expectContent := plantumlHeader + `
[IntegratedSystem] as _0 <<highlight>>
[System1] as _1 <<highlight>>
_0 --> _1
@enduml`
	expected := map[string]string{
		"_.png": expectContent,
	}

	// When
	result := GenerateIntegrations(args.rootModel, args.title, args.output,
		args.project, args.filter, args.modules, args.exclude, args.clustered, args.epa)

	// Then
	assert.Equal(t, expected, result)
}

func TestGenerateIntegrationsWithPassthrough(t *testing.T) {
	// Given
	args := &intsArg{
		rootModel: "./tests/",
		modules:   "integration_passthrough_test.sysl",
		output:    "%(epname).png",
		project:   "Project",
	}

	// When
	result := GenerateIntegrations(args.rootModel, args.title, args.output,
		args.project, args.filter, args.modules, args.exclude, args.clustered, args.epa)

	// Then

	assert.Len(t, reAs.FindAllString(result["_.png"], -1), 3)
	assert.Len(t, reAsWithHighlight.FindAllString(result["_.png"], -1), 1)
	assert.Len(t, rePoint.FindAllString(result["_.png"], -1), 2)
	assert.Len(t, rePointWithIndirect.FindAllString(result["_.png"], -1), 1)
}

func TestDoGenerateIntegrations(t *testing.T) {
	type args struct {
		flags *flag.FlagSet
		args  []string
	}
	argsData := []string{"ints"}
	test := struct {
		name       string
		args       args
		wantStdout string
		wantStderr string
	}{
		"Case-Do generate integrations",
		args{
			flag.NewFlagSet(argsData[0], flag.PanicOnError),
			argsData,
		},
		"",
		"",
	}
	t.Run(test.name, func(t *testing.T) {
		stdout := &bytes.Buffer{}
		stderr := &bytes.Buffer{}
		DoGenerateIntegrations(test.args.args)
		assert.Equal(t, test.wantStdout, stdout.String())
		assert.Equal(t, test.wantStderr, stderr.String())
	})
}

func TestHandleStatement(t *testing.T) {
	intsParam := &collectApplicationDependenciesState{}
	statement := []*sysl.Statement{
		{Stmt: &sysl.Statement_Loop{Loop: &sysl.Loop{Stmt: []*sysl.Statement{}}}},
		{Stmt: &sysl.Statement_LoopN{LoopN: &sysl.LoopN{Stmt: []*sysl.Statement{}}}},
		{Stmt: &sysl.Statement_Foreach{Foreach: &sysl.Foreach{Stmt: []*sysl.Statement{}}}},
		{Stmt: &sysl.Statement_Alt{Alt: &sysl.Alt{Choice: []*sysl.Alt_Choice{{Stmt: []*sysl.Statement{}}}}}},
	}

	intsParam.handleStatement("", "", statement)
	assert.Len(t, intsParam.deps, 0)
}

func TestGenerateIntegrationsWithCluster(t *testing.T) {
	// Given
	args := &intsArg{
		rootModel: "./tests/",
		modules:   "integration_with_cluster.sysl",
		output:    "%(epname).png",
		project:   "Project",
		clustered: true,
	}

	// When
	result := GenerateIntegrations(args.rootModel, args.title, args.output,
		args.project, args.filter, args.modules, args.exclude, args.clustered, args.epa)

	// Then
	assert.Len(t, rePackage.FindAllString(result["_.png"], -1), 1)
	assert.Len(t, reAs.FindAllString(result["_.png"], -1), 3)
	assert.Len(t, reAsWithHighlight.FindAllString(result["_.png"], -1), 1)
	assert.Len(t, rePoint.FindAllString(result["_.png"], -1), 2)
}

func TestGenerateIntegrationsWithEpa(t *testing.T) {
	// Given
	args := &intsArg{
		rootModel: "./tests/",
		modules:   "integration_with_epa.sysl",
		output:    "%(epname).png",
		project:   "Project",
		epa:       true,
	}

	reAsXWithHighlight := regexp.MustCompile(`state "(\w+)" as X_\d+ <<highlight>>`)
	reAsWithHighlight := regexp.MustCompile(`state "(\w+)" as _\d+ <<highlight>>`)
	reSilver := regexp.MustCompile(`_\d+ -\[#silver\]-> _\d+`)
	reBlack := regexp.MustCompile(`_\d+ -\[#black\]> _\d+`)
	reNeedsInt := regexp.MustCompile(`(.*?) needsInt(.*?)`)

	// When
	result := GenerateIntegrations(args.rootModel, args.title, args.output,
		args.project, args.filter, args.modules, args.exclude, args.clustered, args.epa)

	// Then
	assert.Len(t, reAsXWithHighlight.FindAllString(result["_.png"], -1), 3)
	assert.Len(t, reAsWithHighlight.FindAllString(result["_.png"], -1), 3)
	assert.Len(t, reSilver.FindAllString(result["_.png"], -1), 2)
	assert.Len(t, reBlack.FindAllString(result["_.png"], -1), 2)
	assert.Len(t, reNeedsInt.FindAllString(result["_.png"], -1), 2)
}

func TestGenerateIntegrationsWithIndirectArrow(t *testing.T) {
	// Given
	args := &intsArg{
		rootModel: "./tests/",
		modules:   "integration_with_indirect_arrow.sysl",
		output:    "%(epname).png",
		project:   "Project",
	}

	// When
	result := GenerateIntegrations(args.rootModel, args.title, args.output,
		args.project, args.filter, args.modules, args.exclude, args.clustered, args.epa)

	// Then
	assert.Len(t, reAs.FindAllString(result["_.png"], -1), 3)
	assert.Len(t, reAsWithHighlight.FindAllString(result["_.png"], -1), 1)
	assert.Len(t, rePoint.FindAllString(result["_.png"], -1), 2)
	assert.Len(t, rePointWithIndirect.FindAllString(result["_.png"], -1), 1)
}

func TestGenerateIntegrationsWithRestrictBy(t *testing.T) {
	// Given
	args := &intsArg{
		rootModel: "./tests/",
		modules:   "integration_with_restrict_by.sysl",
		output:    "%(epname).png",
		project:   "Project",
		epa:       true,
	}

	reAsXWithHighlight := regexp.MustCompile(`state "(\w+)" as X_\d+ <<highlight>>`)
	reAsWithHighlight := regexp.MustCompile(`state "(\w+)" as _\d+ <<highlight>>`)
	reSilver := regexp.MustCompile(`_\d+ -\[#silver\]-> _\d+`)
	reBlack := regexp.MustCompile(`_\d+ -\[#black\]> _\d+`)

	// When
	result := GenerateIntegrations(args.rootModel, args.title, args.output,
		args.project, args.filter, args.modules, args.exclude, args.clustered, args.epa)

	// Then
	assert.Len(t, reAsXWithHighlight.FindAllString(result["with_restrict_by.png"], -1), 1)
	assert.Len(t, reAsWithHighlight.FindAllString(result["with_restrict_by.png"], -1), 1)
	assert.Len(t, reSilver.FindAllString(result["with_restrict_by.png"], -1), 2)
	assert.Len(t, reBlack.FindAllString(result["with_restrict_by.png"], -1), 2)
	assert.Len(t, reAsXWithHighlight.FindAllString(result["without_restrict_by.png"], -1), 1)
	assert.Len(t, reAsWithHighlight.FindAllString(result["without_restrict_by.png"], -1), 2)
	assert.Len(t, reSilver.FindAllString(result["without_restrict_by.png"], -1), 4)
	assert.Len(t, reBlack.FindAllString(result["without_restrict_by.png"], -1), 3)
}

func TestGenerateIntegrationsWithFilter(t *testing.T) {
	// Given
	args := &intsArg{
		rootModel: "./tests/",
		modules:   "integration_with_filter.sysl",
		output:    "%(epname).png",
		project:   "Project",
		filter:    "_",
	}

	// When
	result := GenerateIntegrations(args.rootModel, args.title, args.output,
		args.project, args.filter, args.modules, args.exclude, args.clustered, args.epa)

	// Then
	assert.Len(t, result, 1)
	assert.Len(t, reAsWithHighlight.FindAllString(result["_.png"], -1), 3)
	assert.Len(t, rePoint.FindAllString(result["_.png"], -1), 4)
}

func TestGenerateIntegrationWithOrWithoutPassThrough(t *testing.T) {
	// Given
	args := &intsArg{
		rootModel: "./tests/",
		modules:   "integration_with_or_without_passthrough.sysl",
		output:    "%(epname).png",
		project:   "Project",
	}

	// When
	result := GenerateIntegrations(args.rootModel, args.title, args.output,
		args.project, args.filter, args.modules, args.exclude, args.clustered, args.epa)

	// Then
	assert.Len(t, reAsWithHighlight.FindAllString(result["with_systema.png"], -1), 2)
	assert.Len(t, reAs.FindAllString(result["with_systema.png"], -1), 4)
	assert.Len(t, rePoint.FindAllString(result["with_systema.png"], -1), 3)
	assert.Len(t, reAsWithHighlight.FindAllString(result["with_passthrough.png"], -1), 1)
	assert.Len(t, reAs.FindAllString(result["with_passthrough.png"], -1), 3)
	assert.Len(t, rePoint.FindAllString(result["with_passthrough.png"], -1), 2)
	assert.Len(t, reAsWithHighlight.FindAllString(result["without_passthrough.png"], -1), 1)
	assert.Len(t, reAs.FindAllString(result["without_passthrough.png"], -1), 2)
	assert.Len(t, rePoint.FindAllString(result["without_passthrough.png"], -1), 1)
}

func TestGenerateIntegrationsWithPubSub(t *testing.T) {
	// Given
	args := &intsArg{
		rootModel: "./tests/",
		modules:   "integration_with_pubsub.sysl",
		output:    "%(epname).png",
		project:   "Project",
		epa:       true,
	}

	reAsXWithHighlight := regexp.MustCompile(`state "(\w+)" as X_\d+ <<highlight>>`)
	reAsWithHighlight := regexp.MustCompile(`state "(\w+)" as _\d+ <<highlight>>`)
	rePubsub := regexp.MustCompile(`_\d+ -\[#blue\]> _\d+`)

	// When
	result := GenerateIntegrations(args.rootModel, args.title, args.output,
		args.project, args.filter, args.modules, args.exclude, args.clustered, args.epa)

	// Then
	assert.Len(t, reAsXWithHighlight.FindAllString(result["_.png"], -1), 1)
	assert.Len(t, reAsWithHighlight.FindAllString(result["_.png"], -1), 1)
	assert.Len(t, rePubsub.FindAllString(result["_.png"], -1), 2)
}
