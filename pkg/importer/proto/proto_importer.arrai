let (:import, :parseFile, ...) = //{./proto_parser};
let (:module, ...) = //{./proto_to_sysl};
let (:renderAllInOne, ...) = //{/pkg/arrai/sysl-renderer/render_mod};

let trimLines = //re.compile(` +(\n|$)`).sub('$1');

let importParsed = \config \parsed
    trimLines($`
        # Code generated by Sysl. DO NOT EDIT.

        ${renderAllInOne(module(config, parsed))}
` ++ '\n');

let importFiles = \config \files
    let (?:importPaths:'', ?:shallow:false, ...) = config;
    let importPaths = cond {importPaths: //seq.split(",", importPaths)} || [];
    let _ = //log.print((:importPaths));
    let _ = //log.print((:files));
    let imported = import((:importPaths), files);

    let filesToExclude = shallow &&
        let allFiles = imported => .@;
        let mainFiles = files => .@item;
        allFiles &~ mainFiles
    ;

    importParsed((:filesToExclude), imported)
;

let importDir = \dir \importPaths
    let isProto = \path //seq.has_suffix(".proto", path);

    let paths = //os.tree(dir) => .path;
    let _ = //log.print((:paths));
    let files = (paths where isProto(.)) orderby .;
    let _ = //log.print((:files));
    let _ = //log.print((:importPaths));

    importFiles((:importPaths), files)
;

let import = \config \input
    cond input {
        [...]: importFiles(config, input),
        _:
            cond {
                //seq.has_suffix('.proto', input): importFiles(config, [input]),
                _: importDir(input, config.importPaths),
            }
    }
;

# FIXME: This is only called when sysl imports a proto files and it does not support import paths yet.
# Implement and test.
let importString = \_ \str importParsed((), {'': parseFile(<<str>>)});

(
    :importString,
    :importFiles,
    :import
)
