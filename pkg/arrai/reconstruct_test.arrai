let (:loadBytes, :newNormalize, ...) = //{./sysl};

let model = newNormalize(loadBytes(//[//encoding.bytes]{./out/model.pb}));
let all = newNormalize(loadBytes(//[//encoding.bytes]{./out/all.pb}));

let reconstruct = //{./reconstruct};

let simpleNoSrc = (
    app: {(appName: ['A'])},
    type: {(appName: ['A'], typeName: 'T')},
    field: {(appName: ['A'], typeName: 'T', fieldName: 'f', fieldType: 'int', fieldOpt: false)},
);

let simple = simpleNoSrc +> (src: (app: {(appName: ['A'], appSrc: (file: 'a.sysl'))}));

let table = (
    src: (app: {(appName: ['A'], appSrc: (file: 'a.sysl'))}),
    app: {(appName: ['A'])},
    type: {(appName: ['A'], typeName: 'Tb')},
    table: {(appName: ['A'], typeName: 'Tb', pk: ['id'])},
    tag: (field: {(appName: ['A'], typeName: 'Tb', fieldName: 'id', fieldTag: 'pk')}),
    field: {
        (appName: ['A'], typeName: 'Tb', fieldName: 'c', fieldType: 'int', fieldOpt: false),
        (appName: ['A'], typeName: 'Tb', fieldName: 'id', fieldType: 'int', fieldOpt: false)
    },
);

let nested = (
    app: {(appName: ['A']), (appName: ['B'])},
    src: (app: {(appName: ['A'], appSrc: (file: 'foo/a.sysl')), (appName: ['B'], appSrc: (file: 'foo/bar/b.sysl'))}),
);

let rest = (
    app: {(appName: ['A'])},
    ep: {(appName: ['A'], epName: 'Ep', rest: (method: 'GET', path: '/path/{p}'))},
    param: {(appName: ['A'], epName: 'Ep', paramName: 'p', paramLoc: 'path', paramIndex: 0, paramOpt: false, paramType: (primitive: ('INT')))},
    src: (app: {(appName: ['A'], appSrc: (file: 'a.sysl'))}),
);

(
    # Note: The following tests are commented out due to failure.
    #all: reconstruct(all) = //{./test_reconstruct_all},
    #model: reconstruct(model) = //{./test_reconstruct_model},

    simple: reconstruct(simple) = {
        'a.sysl': $`
            A:
                !type T:
                    f <: int

        `
    },

    simpleNoSrc: reconstruct(simpleNoSrc) = {
        'default.sysl': $`
            A:
                !type T:
                    f <: int

        `
    },

    optional:
        let data = simple +> (field: simple.field => . +> (fieldOpt: true));
        reconstruct(data) = {
            'a.sysl': $`
                A:
                    !type T:
                        f <: int?

            `
        },

    newline: reconstruct(simple +> (anno: (field: {
        (simple.field single) +> (fieldAnnoName: 'desc', fieldAnnoValue: '\n')
    }))) = {
        'a.sysl': $`
            A:
                !type T:
                    f <: int:
                        @desc =:
                            |

        `
    },

    tags:
        let appTag = (appName: ['A'], appTag: 'app_tag');
        let typeTag = (appName: ['A'], typeName: 'T', typeTag: 'type_tag');
        let fieldTag = (appName: ['A'], typeName: 'T', fieldName: 'f', fieldTag: 'field_tag');
        let tableTag = (appName: ['A'], typeName: 'Tb', typeTag: 'table_tag');
        let columnTag = (appName: ['A'], typeName: 'Tb', fieldName: 'c', fieldTag: 'column_tag');
        (
            noTags: reconstruct(simple) = {
                'a.sysl': $`
                    A:
                        !type T:
                            f <: int

                `
            },
            onApp: reconstruct(simple +> (tag: (app: {appTag}))) = {
                'a.sysl': $`
                    A [~app_tag]:
                        !type T:
                            f <: int

                `
            },
            onType: reconstruct(simple +> (tag: (type: {typeTag}))) = {
                'a.sysl': $`
                    A:
                        !type T [~type_tag]:
                            f <: int

                `
            },
            onField: reconstruct(simple +> (tag: (field: {fieldTag}))) = {
                'a.sysl': $`
                    A:
                        !type T:
                            f <: int [~field_tag]

                `
            },

            noTagsTable: reconstruct(table) = {
                'a.sysl': $`
                    A:
                        !table Tb:
                            c <: int
                            id <: int [~pk]

                `
            },
            noTagsMixed: reconstruct(table +> (type: table.type | simple.type, field: table.field | simple.field)) = {
                'a.sysl': $`
                    A:
                        !type T:
                            f <: int
                    
                        !table Tb:
                            c <: int
                            id <: int [~pk]

                `
            },
            onTable: reconstruct(table +> (tag: table.tag +> (type: {tableTag}))) = {
                'a.sysl': $`
                    A:
                        !table Tb [~table_tag]:
                            c <: int
                            id <: int [~pk]

                `
            },
            onColumn: reconstruct(table +> (tag: (field: table.tag.field | {columnTag}))) = {
                'a.sysl': $`
                    A:
                        !table Tb:
                            c <: int [~column_tag]
                            id <: int [~pk]

                `
            },
            onPK: reconstruct(table +> (tag: (field: table.tag.field | {columnTag +> (fieldName: 'id')}))) = {
                'a.sysl': $`
                    A:
                        !table Tb:
                            c <: int
                            id <: int [~column_tag, ~pk]

                `
            },
        )
    ,

    nested:
        let expected = {
            'foo': {
                'a.sysl': $`
                    A:
                        ...

                `,
                'bar': {
                    'b.sysl': $`
                        B:
                            ...

                    `
                },
            },
        };
        let actual = reconstruct(nested);
        //test.assert.equal(expected, actual)
    ,

    rest:
        reconstruct(rest) = {
            'a.sysl': $`
                A:
                    /path/{p <: int}:
                        GET:
                            ...

            `
        }
    ,
)
